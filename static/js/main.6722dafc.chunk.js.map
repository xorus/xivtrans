{"version":3,"sources":["component/LangSelector.tsx","component/ResultItem.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["LangSelector","props","size","onChange","value","defaultValue","languages","map","itemLang","Option","key","toUpperCase","ResultItem","className","src","item","Icon","alt","displayedLangs","l","runSearch","term","lang","a","length","console","log","fetch","encodeURIComponent","join","query","ok","json","results","Results","App","useState","search","setSearch","setResults","savedDisplayedLangs","JSON","parse","localStorage","getItem","_setDisplayedLangs","savedLang","includes","_setLang","useEffect","Content","offsetTop","checked","e","langs","newLangs","target","index","indexOf","splice","setItem","stringify","Group","compact","setLang","Search","onSearch","newValue","autoFocus","style","width","result","ID","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.6722dafc.chunk.js","sourcesContent":["import {XivLang} from \"../types\";\r\nimport {Select} from \"antd\";\r\nimport React from \"react\";\r\n\r\nexport function LangSelector(props: {\r\n    languages: XivLang[],\r\n    value: XivLang,\r\n    onChange: (lang: XivLang) => void\r\n}) {\r\n    return <Select size={\"large\"} onChange={(value) => {\r\n        props.onChange(value as XivLang);\r\n    }} defaultValue={props.value}>\r\n        {props.languages.map((itemLang) => (\r\n            <Select.Option key={itemLang} value={itemLang}>\r\n                {itemLang.toUpperCase()}\r\n            </Select.Option>\r\n        ))}\r\n    </Select>;\r\n}","import React from \"react\";\r\nimport {Result, XivLang} from \"../types\";\r\n\r\nexport function ResultItem(props: {\r\n    displayedLangs: XivLang[],\r\n    item: Result\r\n}) {\r\n    return <div className={\"result\"}>\r\n        <div className=\"left\">\r\n            <img src={`https://xivapi.com/${props.item.Icon}`} alt=\"\" className={\"icon\"}/>\r\n        </div>\r\n        <div className=\"content\">\r\n            {props.displayedLangs.map((l) => {\r\n                return <span key={l}>\r\n                        {l.toUpperCase()} {(props.item as any)[\"Name_\" + l]} <br/>\r\n                    </span>;\r\n            })}\r\n        </div>\r\n    </div>;\r\n}","import React, {useEffect, useState} from 'react';\nimport './App.css';\nimport 'antd/dist/antd.dark.css';\nimport {Affix, Checkbox, Input, Layout} from \"antd\";\nimport {Result, XivLang} from \"./types\";\nimport {LangSelector} from \"./component/LangSelector\";\nimport {ResultItem} from \"./component/ResultItem\";\n\nconst languages: XivLang[] = [\"en\", \"fr\", \"ja\", \"de\"];\n\nasync function runSearch(term: string, lang: XivLang) {\n    if (term.length === 0) {\n        return false;\n    }\n\n    console.log(\"Searching for \" + term);\n\n    const query = await fetch(\"https://xivapi.com/search?language=\" + lang +\n        \"&string=\" + encodeURIComponent(term) +\n        \"&columns=ID,Icon,Url,Name,Name_\" + languages.join(',Name_')\n    );\n    if (!query.ok) {\n        return false;\n    }\n    const results = await query.json();\n    return results.Results as Result[];\n}\n\nfunction App() {\n    const [search, setSearch] = useState<string>(\"\");\n    const [results, setResults] = useState<Result[]>([]);\n\n    // fixme: not safe\n    const savedDisplayedLangs = JSON.parse(localStorage.getItem(\"displayedLangs\") ?? '[\"en\", \"fr\"]');\n    const [displayedLangs, _setDisplayedLangs] = useState<XivLang[]>(savedDisplayedLangs);\n    const setDisplayedLangs = (langs: XivLang[]) => {\n        localStorage.setItem(\"displayedLangs\", JSON.stringify(langs));\n        _setDisplayedLangs(langs);\n    }\n\n    let savedLang = localStorage.getItem(\"lang\") ?? \"en\";\n    if (!(languages as string[]).includes(savedLang)) {\n        savedLang = \"en\";\n    }\n    const [lang, _setLang] = useState<XivLang>(savedLang as XivLang);\n    const setLang = (lang: XivLang) => {\n        localStorage.setItem(\"lang\", lang);\n        _setLang(lang);\n    }\n\n    useEffect(() => {\n        (async () => {\n            const results = await runSearch(search, lang);\n            if (results) {\n                setResults(results);\n            }\n        })();\n    }, [lang, search]);\n\n    return (\n        <Layout>\n            <Layout.Content>\n                <div className=\"App\">\n                    <Affix offsetTop={0}>\n                        <div className=\"search\">\n                            {languages.map((l) => {\n                                return <label key={l}>\n                                    <Checkbox checked={displayedLangs.includes(l)} onChange={e => {\n                                        let newLangs = [...displayedLangs];\n                                        if (e.target.checked) {\n                                            if (!displayedLangs.includes(l)) {\n                                                newLangs = [...newLangs, l]\n                                            }\n                                        } else {\n                                            const index = displayedLangs.indexOf(l);\n                                            if (index >= 0) {\n                                                newLangs.splice(index, 1);\n                                            }\n                                        }\n                                        setDisplayedLangs(newLangs);\n                                    }}>\n                                        {l.toUpperCase()}\n                                    </Checkbox>\n                                </label>;\n                            })}\n\n                            <Input.Group compact>\n                                <LangSelector languages={languages} value={lang}\n                                              onChange={(value) => setLang(value)}/>\n                                <Input.Search size={\"large\"} onSearch={newValue => {\n                                    setSearch(newValue);\n                                }} autoFocus={true} style={{width: \"80vw\"}}/>\n                            </Input.Group>\n                        </div>\n                    </Affix>\n                    <div className={\"results\"}>\n                        {results.map((result: any) => {\n                            return <ResultItem key={result.ID} displayedLangs={displayedLangs} item={result}/>;\n                        })}\n                    </div>\n                </div>\n            </Layout.Content>\n        </Layout>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}