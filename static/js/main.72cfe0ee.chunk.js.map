{"version":3,"sources":["component/LangSelector.tsx","garlandLink.ts","component/ResultItem.tsx","navigation.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["LangSelector","props","size","onChange","value","defaultValue","languages","map","itemLang","Option","key","toUpperCase","garlandLink","item","base","matching","Array","isArray","Url","toLowerCase","indexOf","ID","encodeURI","Name","ResultItem","className","href","target","src","Icon","alt","data-id","data-url","displayedLangs","l","NavigationHandler","navigationHashCache","getSearchFromNavigation","forceRefresh","hash","window","location","includes","matches","decodeURIComponent","substr","length","match","search","searchTerm","groups","trim","language","setSearchInNavigation","lang","encodeURIComponent","addEventListener","nav","cache","Map","runSearch","term","a","cacheKey","has","get","fetch","join","query","ok","json","results","Results","set","navigation","App","storedNavigation","useState","setSearch","setResults","savedDisplayedLangs","JSON","parse","localStorage","getItem","forEach","push","getSavedLangs","_setDisplayedLangs","savedLang","_setLang","setLang","subscribe","search1","useEffect","Content","offsetTop","checked","e","langs","newLangs","index","splice","setItem","stringify","Group","compact","Search","onSearch","newValue","autoFocus","style","width","justify","xs","sm","md","lg","result","Boolean","hostname","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.72cfe0ee.chunk.js","sourcesContent":["import {XivLang} from \"../types\";\r\nimport {Select} from \"antd\";\r\nimport React from \"react\";\r\n\r\nexport function LangSelector(props: {\r\n    languages: XivLang[],\r\n    value: XivLang,\r\n    onChange: (lang: XivLang) => void\r\n}) {\r\n    return <Select size={\"large\"} onChange={(value) => {\r\n        props.onChange(value as XivLang);\r\n    }} defaultValue={props.value}>\r\n        {props.languages.map((itemLang) => (\r\n            <Select.Option key={itemLang} value={itemLang}>\r\n                {itemLang.toUpperCase()}\r\n            </Select.Option>\r\n        ))}\r\n    </Select>;\r\n}","import {Result} from \"./types\";\r\n\r\nexport function garlandLink(item: Result): string {\r\n    const base =\"https://garlandtools.org/db/#\";\r\n\r\n    const replaceMatching = [\r\n        \"item\",\r\n        \"quest\",\r\n        \"achievement\",\r\n        \"action\",\r\n        \"status\",\r\n        \"fate\",\r\n        \"leve\",\r\n        [\"ENpcResident\", \"npc\"]\r\n    ];\r\n    for (let matching of replaceMatching) {\r\n        if (Array.isArray(matching)) {\r\n            if (item.Url.toLowerCase().indexOf(`/${matching[0]}`) === 0) {\r\n                return `${base}${matching[1]}/${item.ID}`;\r\n            }\r\n            continue;\r\n        }\r\n\r\n        if (item.Url.toLowerCase().indexOf(`/${matching}`) === 0) {\r\n            return `${base}${matching}/${item.ID}`;\r\n        }\r\n    }\r\n\r\n    return \"https://garlandtools.org/db/#search/\" + encodeURI(item.Name);\r\n}","import React from \"react\";\r\nimport {Result, XivLang} from \"../types\";\r\nimport {garlandLink} from \"../garlandLink\";\r\n\r\nexport function ResultItem(props: {\r\n    displayedLangs: XivLang[],\r\n    item: Result\r\n}) {\r\n    return <div className={\"result\"}>\r\n        <div className=\"left\">\r\n            <a href={garlandLink(props.item)}\r\n               target={\"blank\"}>\r\n                <img src={`https://xivapi.com/${props.item.Icon}`} alt=\"\" className={\"icon\"}/>\r\n            </a>\r\n        </div>\r\n        <div className=\"content\" data-id={props.item.ID} data-url={props.item.Url}>\r\n            {props.displayedLangs.map((l) => {\r\n                return <span key={l}>\r\n                        {l.toUpperCase()} {(props.item as any)[\"Name_\" + l]} <br/>\r\n                    </span>;\r\n            })}\r\n        </div>\r\n    </div>;\r\n}","import {XivLang} from \"./types\";\r\n\r\nexport class NavigationHandler {\r\n    private navigationHashCache: string | null = null;\r\n\r\n    public subscribe(onChange: (lang: XivLang, search: string) => void) {\r\n        window.addEventListener(\"hashchange\", () => {\r\n            if (this.navigationHashCache !== window.location.hash) {\r\n                const nav = this.getSearchFromNavigation(true);\r\n                if (nav) {\r\n                    onChange(nav.language as XivLang, nav.search);\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    public getSearchFromNavigation = (forceRefresh?: boolean) => {\r\n        let hash = '';\r\n        if (forceRefresh) {\r\n            hash = window.location.hash;\r\n        } else {\r\n            hash = this.navigationHashCache ?? window.location.hash;\r\n        }\r\n\r\n        if (hash) {\r\n            if (hash.includes('/search/')) {\r\n                const search = decodeURIComponent(hash.substr('/search/'.length + 1));\r\n                const matches = search.match(/^\\/?(?<language>fr|en|ja|de)*\\/(?<search>.+)/);\r\n                if (matches) {\r\n                    const searchTerm = matches.groups?.search.trim();\r\n                    if (searchTerm && searchTerm.length > 0) {\r\n                        return {\r\n                            language: matches.groups?.language ?? \"en\",\r\n                            search: searchTerm\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    public setSearchInNavigation = (lang: XivLang, search: string) => {\r\n        this.navigationHashCache = `/search/${lang}/${encodeURIComponent(search)}`;\r\n        window.location.hash = this.navigationHashCache;\r\n    }\r\n}","import React, {useEffect, useState} from 'react';\nimport './App.css';\nimport 'antd/dist/antd.dark.css';\nimport {Affix, Checkbox, Col, Input, Layout, Row} from \"antd\";\nimport {Result, XivLang} from \"./types\";\nimport {LangSelector} from \"./component/LangSelector\";\nimport {ResultItem} from \"./component/ResultItem\";\nimport {NavigationHandler} from \"./navigation\";\n\nconst languages: XivLang[] = [\"en\", \"fr\", \"ja\", \"de\"];\n\nconst cache = new Map<string, Result[]>();\n\nasync function runSearch(term: string, lang: XivLang) {\n    if (term.length === 0) {\n        return false;\n    }\n\n    const cacheKey = lang + term;\n    if (cache.has(cacheKey)) {\n        return cache.get(cacheKey);\n    }\n\n    const query = await fetch(\"https://xivapi.com/search?language=\" + lang +\n        \"&string=\" + encodeURIComponent(term) +\n        \"&columns=ID,Icon,Url,Name,Name_\" + languages.join(',Name_')\n    );\n    if (!query.ok) {\n        return false;\n    }\n    const results = ((await query.json()).Results) as Result[];\n\n    cache.set(cacheKey, results);\n    return results;\n}\n\nlet _savedLangCache: XivLang[] | null = null;\n\n/**\n * Validate possible user input (don't allow an invalid lang)\n */\nfunction getSavedLangs(): XivLang[] {\n    if (_savedLangCache !== null) {\n        return _savedLangCache;\n    }\n\n    const savedDisplayedLangs = JSON.parse(localStorage.getItem(\"displayedLangs\") ?? '[\"en\", \"fr\"]');\n    const displayedLangs: XivLang[] = [];\n    savedDisplayedLangs.forEach((item: string) => {\n        if ((languages as string[]).includes(item)) {\n            displayedLangs.push(item as XivLang);\n        }\n    })\n\n    return displayedLangs;\n}\n\nconst navigation = new NavigationHandler();\n\nlet subscibed = false;\n\nfunction App() {\n    const storedNavigation = navigation.getSearchFromNavigation();\n\n    const [search, setSearch] = useState<string>(storedNavigation?.search ?? \"\");\n    const [results, setResults] = useState<Result[]>([]);\n    const [displayedLangs, _setDisplayedLangs] = useState<XivLang[]>(getSavedLangs());\n    const setDisplayedLangs = (langs: XivLang[]) => {\n        localStorage.setItem(\"displayedLangs\", JSON.stringify(langs));\n        _setDisplayedLangs(langs);\n    }\n\n    let savedLang = storedNavigation?.language ?? localStorage.getItem(\"lang\") ?? \"en\";\n    if (!(languages as string[]).includes(savedLang)) {\n        savedLang = \"en\";\n    }\n    const [lang, _setLang] = useState<XivLang>(savedLang as XivLang);\n    const setLang = (lang: XivLang) => {\n        _setLang(lang);\n    }\n\n    if (!subscibed) {\n        navigation.subscribe((lang, search1) => {\n            setLang(lang)\n            setSearch(search1);\n        });\n    }\n\n    // navbar search\n    useEffect(() => {\n        if (storedNavigation && storedNavigation?.search !== search) {\n            setSearch(storedNavigation.search);\n        }\n    }, [storedNavigation, lang, search])\n\n    useEffect(() => {\n        (async () => {\n            const results = await runSearch(search, lang);\n            if (results) {\n                setResults(results);\n            }\n            navigation.setSearchInNavigation(lang, search);\n        })();\n    }, [lang, search]);\n\n    return (\n        <Layout>\n            <Layout.Content>\n                <div className=\"App\">\n                    <Affix offsetTop={0}>\n                        <div className=\"search\">\n                            {languages.map((l) => {\n                                return <label key={l}>\n                                    <Checkbox checked={displayedLangs.includes(l)} onChange={e => {\n                                        let newLangs = [...displayedLangs];\n                                        if (e.target.checked) {\n                                            if (!displayedLangs.includes(l)) {\n                                                newLangs = [...newLangs, l]\n                                            }\n                                        } else {\n                                            const index = displayedLangs.indexOf(l);\n                                            if (index >= 0) {\n                                                newLangs.splice(index, 1);\n                                            }\n                                        }\n                                        setDisplayedLangs(newLangs);\n                                    }}>\n                                        {l.toUpperCase()}\n                                    </Checkbox>\n                                </label>;\n                            })}\n\n                            <Input.Group compact>\n                                <LangSelector languages={languages} value={lang}\n                                              onChange={(value) => setLang(value)}/>\n                                <Input.Search size={\"large\"} onSearch={newValue => {\n                                    setSearch(newValue);\n                                }} autoFocus={true} style={{width: \"80vw\"}} defaultValue={search}/>\n                            </Input.Group>\n                        </div>\n                    </Affix>\n                    <Row justify={\"center\"}>\n                        <Col xs={24} sm={20} md={16} lg={10}>\n                            <div className={\"results\"}>\n                                {results.map((result: any) => {\n                                    return <ResultItem key={result.ID} displayedLangs={displayedLangs} item={result}/>;\n                                })}\n                            </div>\n                        </Col>\n                    </Row>\n                </div>\n            </Layout.Content>\n        </Layout>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}